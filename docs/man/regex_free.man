.\" Automatically generated by Pandoc 2.11.4
.\"
.TH "regex_compile" "3" "April 5, 2021" "rationL 0.1.0" "rationL User Manual"
.hy
.SH NAME
.PP
regex_compile regex_free \[en] Compile a regular expression from a
pattern
.SH SYNOPSIS
.IP
.nf
\f[C]
#include <rationl.h>

reg_t regex_compile(char* pattern);

void regex_free(reg_t re);
\f[R]
.fi
.SH DESCRIPTION
.PP
\f[B]regex_compile()\f[R] takes a regular expression pattern and
compiles it into a regular expression matching the pattern.
.PP
The value returned is a \f[B]reg_t\f[R] structure containing the
folowing fields:
.IP
.nf
\f[C]
typedef struct reg_t
{
    Automaton* aut;
    char* pattern;
} regex_t;
\f[R]
.fi
.PP
\f[I]aut\f[R] This fields hold a compiled automaton that matches the
pattern passed as argument to the compile function.
This automaton will then be used by the other function to performs the
operations on the automaton.
.PP
\f[I]pattern\f[R] This fields hold the pattern passed as argument.
.SS REGULAR EXPRESSION FORMAT
.PP
Currently supported regular expression operators are :
.PP
\f[I]?\f[R] Corresponds to zero or one occurence of the element.
For instance, the regular expression \f[B]aa?\f[R] will match
\f[B]a\f[R] and \f[B]aa\f[R] but will not match \f[B]aaa\f[R].
.PP
\f[I]*\f[R] Corresponds to zero, one or several the the precedent
element.
The regular expression \f[B]a*\f[R] matches an empty string,
\f[B]a\f[R], \f[B]aaaa\&...\f[R] but will not match \f[B]ab\f[R].
.PP
\f[I]+\f[R] Corresponds to at least one element.
The regular expression \f[B]a+\f[R] will match \f[B]a\f[R],
\f[B]aa\f[R], \f[B]aaaaaa\&...\f[R] but will not match an empty string.
.PP
\f[I]{n}\f[R] Repeats the element n times.
For instance the regular expression \f[B]b{4}\f[R] wil match only match
\f[B]bbbb\f[R].
.PP
\f[I]{n,}\f[R] Repeats at least the element n times.
The regular expression \f[B]b{4,}\f[R] wil match \f[B]bbbb\f[R],
\f[B]bbbbb\&...\f[R] but will not match \f[B]bb\f[R] or \f[B]bbb\f[R].
.PP
\f[I]{n,p}\f[R] Repeats between n and p times the element preceding the
\&.
The regular expression \f[B]b{4,}\f[R] wil match \f[B]bbbb\f[R],
\f[B]bbbbb\&...\f[R] but will not match \f[B]bb\f[R] or \f[B]bbb\f[R].
.PP
\f[I]a|b\f[R] Matches expression a or b.
For instance the regular expression \f[B]a|b\f[R] will match \f[B]a\f[R]
and \f[B]b\f[R] but will not match \f[B]ab\f[R].
This operator as the lowest precedence meaning that \f[B]aa|bb\f[R] will
match either \f[B]aa\f[R] or \f[B]bb\f[R].
.PP
\f[I]()\f[R] When a pattern or an expression is put between parenthesis,
it enforces precedence.
For example the regular expression defined as \f[B](aa)?\f[R] will match
if \f[B]aa\f[R] occurs zero or one time.
.PP
\f[I][]\f[R] This operator creates a group of caracters than can be
matched.
Consider the regular expression \f[B][abc]\f[R].
This expression will match \f[B]a\f[R], \f[B]b\f[R] or \f[B]c\f[R].
When a group is defined using - like in [A-Z] it will match all the
caracters in the ASCII order contained between A and Z.
To match all alphanumerical word you can use the folowing expression
[A-Za-z0-9] that will match either a caracter between A and Z, a
caracter between a and z or a number between 0 and 9.
.PP
\f[I]\[rs]w\f[R] This is equivalent to writing [A-Za-z0-9_].
Matches all alphanumerical words including and underscores.
.PP
\f[I]\[rs]W\f[R] This matches everything except all the caracters in
\[rs]w
.PP
\f[I]\[rs]d\f[R] This is equivalent to writing [0-9].
Matches all numbers.
.PP
\f[I]\[rs]D\f[R] This matches everything except all the caracters in
\[rs]d
.PP
\f[I]\[rs]s\f[R] Matches all blank characters (\[rs]t, \[rs]n, \[rs]r,
\[rs]v) and spaces.
.PP
\f[I]\[rs]S\f[R] Matches everything that is not a blank character.
.SH RETURN VALUE
.PP
\f[B]regex_compiles()\f[R] returns a element of the reg_t struct or NULL
on failure to compile the regular expression.
.PP
This regular expression needs to be freed using the
\f[B]regex_free()\f[R] function.
