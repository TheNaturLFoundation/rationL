.\" Automatically generated by Pandoc 2.11.4
.\"
.TH "regex_search" "3" "April 5, 2021" "rationL 0.1.0" "rationL User Manual"
.hy
.SH NAME
.PP
regex_search \[en] Searches substring that matches a regular expression
.SH SYNOPSIS
.IP
.nf
\f[C]
#include <rationl.h>

size_t regex_search(reg_t re, char *input, char **matches[]);
\f[R]
.fi
.SH DESCRIPTION
.PP
\f[B]regex_search()\f[R] searches maximal subtring that the regular
expression given as parameter matches.
Copies all occurences found in the form of a list of string in the
\f[I]output\f[R] parameter.
The output parameter does not need to be allocated but will need to be
freed.
.PP
\f[I]re\f[R] The regular expression compiled using (regex_compile).
.PP
\f[I]input\f[R] The input string to match against the regular expression
.PP
\f[I]matches\f[R] This pointer contains a list of string that was
allocated by the regex_search function.
The string in the list are ordered in order of detection from left to
right in the input string.
This list will need to be freed by the user.
.SH RETURN VALUE
.PP
\f[B]regex_search()\f[R] returns the size of the list of string that has
been matched by the regular expression.
.SH EXAMPLES
.PP
\f[B]Programs that returns all function defined in a C source file\f[R]
.IP
.nf
\f[C]
#include <err.h>
#include <rationl.h>
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char **argv)
{
    if (argc != 2)
        errx(1, \[dq]No input file found.\[dq]);

    reg_t re = regex_compile(
        \[dq]\[rs]\[rs]w+(\[rs]\[rs]s|\[rs]\[rs]*)+\[rs]\[rs]w+\[rs]\[rs]([ A-Za-z0-9,*]*\[rs]\[rs])\[dq]);

    char *line_buf = NULL;
    size_t line_buf_size = 0;
    int line_count = 0;
    ssize_t line_size;
    FILE *fp = fopen(argv[1], \[dq]r\[dq]);
    if (!fp)
    {
        errx(EXIT_FAILURE, \[dq]Error opening file \[aq]%s\[aq]\[rs]n\[dq], argv[1]);
    }

    char**groups;



    while ((line_size = getline(&line_buf, &line_buf_size, fp) >= 0))
    {
        line_count++;

        size_t match_size = regex_search(re, line_buf, &groups);

        for (size_t i = 0; i < match_size; i++)
        {
            printf(\[dq]%s\[rs]n\[dq], groups[i]);
            free(groups[i]);
        }
        free(groups);
    }

    free(line_buf);
    fclose(fp);
    regex_free(re);
    return 0;
}
\f[R]
.fi
